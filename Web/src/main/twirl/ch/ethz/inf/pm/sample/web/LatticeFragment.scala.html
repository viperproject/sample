@(state: ch.ethz.inf.pm.sample.abstractdomain.Lattice[_])
@import ch.ethz.inf.pm.sample.abstractdomain._
@import ch.ethz.inf.pm.sample.abstractdomain.numericaldomain._

@state match {
    case s: vdha.ValueDrivenHeapStateWithSymbolicPredicates.EdgeStateDomain[_] => {
        @CartesianProductDomain(List(
            s.valueState.valueState,
            s.valueState.symbolicPredicateState.instances,
            s.valueState.symbolicPredicateState.definitions,
            s.edgeAmbiguityState))
    }
    case i: vdha.SymbolicPredicateInstsDomain => {
        @LatticeDescription("Instances")
        @SymbolicPredicateInstsDomain(i)
    }
    case d: vdha.SymbolicPredicateDefsDomain => {
        @LatticeDescription("Definitions")
        @FunctionalDomain(d)
    }
    case s: vdha.SymbolicPredicateDef => {
        @SymbolicPredicateDef(s)
    }
    case g: vdha.EdgeAmbiguityState => {
        @LatticeDescription("Edge Ambiguity")
        @FunctionalDomain(g)
    }
    case a: ApronInterface[_] => {
        @* ApronInterface itself must come after any subclasses of ApronInterface *@
        @LatticeDescription("Values")
        @ApronInterface(a)
    }
    case c: CartesianProductDomain[_, _, _] => {
        @CartesianProductDomain(List(c._1, c._2))
    }
    case s: SetDomain[_, _] => {
        @s
    }
    case f: FunctionalDomain[_, _, _] => {
        @FunctionalDomain(f)
    }
}

@SymbolicPredicateInstsDomain(i: vdha.SymbolicPredicateInstsDomain) = {
    <dl class="functional-domain">
        <dt>Folded</dt>
        <dd>@i.certainlyFoldedIds.mkString(", ")</dd>
        <dt>Unfolded</dt>
        <dd>@i.certainlyUnfoldedIds.mkString(", ")</dd>
        <dt>Raw</dt>
        <dd>@ApronInterface(i)</dd>
    </dl>
    <div class="clearfix"></div>
}

@SymbolicPredicateDef(s: vdha.SymbolicPredicateDef) = {
    @if(s.valFieldPerms.isTop && s.refFieldPerms.isTop) {
        @Top()
    } else {
        @if(s.valFieldPerms.isBottom || s.refFieldPerms.isBottom) {
            @Bottom()
        } else {
            <ul class="symbolic-predicate-def">
                @s.valFieldPerms.value.map { fieldName =>
                <li>@fieldName</li>
                }
                @s.refFieldPerms.map.map { fieldNameAndId =>
                <li>@fieldNameAndId._1 → @fieldNameAndId._2.value.map(_.getName).mkString(",")</li>
                }
            </ul>
        }
    }
}

@ApronInterface(a: ApronInterface[_]) = {
    @if(a.isBottom) {
        @Bottom()
    } else {
        @if(a.isTop) {
            @Top()
        } else {
            <ul class="list-unstyled apron-interface">
                @ApronInterfaceTranslator.translate(a).map(ExpPrettyPrinter).toList.sorted.map { line =>
                <li>@line</li>
                }
            </ul>
        }
    }
}

@FunctionalDomain(f: FunctionalDomain[_, _, _]) = {
    @if(f.isBottom) {
        @Bottom()
    } else {
        @if(f.isTop) {
            @Top()
        } else {
            <dl class="functional-domain">
                @f.map.map { keyValuePair =>
                <dt>@keyValuePair._1</dt>
                <dd>@LatticeFragment(keyValuePair._2.asInstanceOf[Lattice[_]])</dd>
                }
            </dl>
            <div class="clearfix"></div>
        }
    }
}

@CartesianProductDomain(lattices: List[Lattice[_]]) = {
    <ul class="list-unstyled cartesian-product-domain">
        @lattices.map { lattice =>
        <li class="cartesian-product-domain-part well well-sm">
            @LatticeFragment(lattice)
        </li>
        }
    </ul>
}

@Top() = {
   <div class="lattice-top">⊤</div>
}

@Bottom() = {
    <div class="lattice-bottom">⊥</div>
}

@LatticeDescription(s: String) = {
    <div class="lattice-description">@s</div>
}
