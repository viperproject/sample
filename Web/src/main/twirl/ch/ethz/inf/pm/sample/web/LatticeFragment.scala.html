@(state: ch.ethz.inf.pm.sample.abstractdomain.Lattice[_])
@import ch.ethz.inf.pm.sample.abstractdomain._
@import ch.ethz.inf.pm.sample.abstractdomain.numericaldomain._

@state match {
    case s: vdha.ValueDrivenHeapStateWithSymbolicPredicates.EdgeStateDomain[_] => {
        @CartesianProductDomain(List(s.valueState._1, s.valueState._2._1, s.valueState._2._2, s.edgeAmbiguityState))
    }
    case i: vdha.SymbolicPredicateInstsDomain => {
        @LatticeDescription("Instances")
        @ApronInterface(i)
    }
    case d: vdha.SymbolicPredicateDefsDomain => {
        @LatticeDescription("Definitions")
        @FunctionalDomain(d)
    }
    case g: vdha.EdgeAmbiguityState => {
        @LatticeDescription("Edge Ambiguity")
        @FunctionalDomain(g)
    }
    case a: ApronInterface[_] => {
        @LatticeDescription("Values")
        @ApronInterface(a)
    }
    case s: vdha.SymbolicPredicateDef => {
        @if(s.valFieldPerms.isTop && s.refFieldPerms.isTop) {
            @Top()
        } else {
            <dl class="symbolic-predicate-def">
            @if(!s.valFieldPerms.isTop) {
                <dt class="lattice-description">Vals</dt>
                <dd>@s.valFieldPerms.value.mkString(", ")</dd>
            }
            @if(!s.refFieldPerms.isTop) {
                <dt class="lattice-description">Refs</dt>
                <dd>@s.refFieldPerms.map.keys.mkString(", ")</dd>
            }
            </dl>
        }
    }
    case c: CartesianProductDomain[_, _, _] => {
        @CartesianProductDomain(List(c._1, c._2))
    }
    case s: SetDomain[_, _] => {
        @s
    }
    case f: FunctionalDomain[_, _, _] => {
        @FunctionalDomain(f)
    }
}

@ApronInterface(a: ApronInterface[_]) = {
    @if(a.isBottom) {
        @Bottom()
    } else {
        @if(a.isTop) {
            @Top()
        } else {
            <ul class="list-unstyled apron-interface">
                @ApronInterfaceTranslator.translate(a).map(ExpPrettyPrinter).toList.sorted.map { line =>
                <li>@line</li>
                }
            </ul>
        }
    }
}

@FunctionalDomain(f: FunctionalDomain[_, _, _]) = {
    @if(f.isBottom) {
        @Bottom()
    } else {
        @if(f.isTop) {
            @Top()
        } else {
            <dl class="functional-domain">
                @f.map.map { keyValuePair =>
                <dt>@keyValuePair._1</dt>
                <dd>@LatticeFragment(keyValuePair._2.asInstanceOf[Lattice[_]])</dd>
                }
            </dl>
            <div class="clearfix"></div>
        }
    }
}

@CartesianProductDomain(lattices: List[Lattice[_]]) = {
    <ul class="list-unstyled cartesian-product-domain">
        @lattices.map { lattice =>
        <li class="cartesian-product-domain-part well well-sm">
            @LatticeFragment(lattice)
        </li>
        }
    </ul>
}

@Top() = {
   <div class="lattice-top">⊤</div>
}

@Bottom() = {
    <div class="lattice-bottom">⊥</div>
}

@LatticeDescription(s: String) = {
    <div class="lattice-description">@s</div>
}
