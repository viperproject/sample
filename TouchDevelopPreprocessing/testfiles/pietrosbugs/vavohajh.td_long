meta version "v2.2,nothing";
meta name "Туда и обратно";
meta icon "suitcase";
meta color "#ffa52a2a";
// App to retrieve local rail timetables. The app has now been translated into English as well, but will likely only be useful in Russia. Приложение пригодится тем, кто регулярно ездит в электричках по определенному маршруту.
//
// Позволяет сохранить закладки на используемые маршруты, или закрепить маршрут на стартовом экране для быстрого доступа к расписаниям. Режим туда и обратно предлагает расписание до одного из двух выбранных пунктов автоматически в зависимости от времени суток, а также с учетом местоположения, если задать местоположение-подсказку.
//
// Версия с исправлениями ошибок.
meta platform "current";

action main() {
  data→launch_default := false;
  data→app_start := time→now;
  code→setup_defaults;
  code→default_buttons;
  //
  if data→start_screen→is_empty then {
    data→start_screen := code→\_("маршруты");
  }
  if data→start_screen→equals(code→\_("маршруты")) then {
    data→launch_default := true;
  }
  else {
    if data→start_screen→equals(code→\_("туда и обратно")) then {
      data→launch_default := true;
    }
    else {
      if data→start_screen→equals(code→\_("маршрут 1")) then {
        data→launch_default := true;
      }
      else {
        if data→start_screen→equals(code→\_("маршрут 2")) then {
          data→launch_default := true;
        }
        else {
          if data→start_screen→equals(code→\_("маршрут 3")) then {
            data→launch_default := true;
          }
          else {
            if data→start_screen→equals(code→\_("маршрут 4")) then {
              data→launch_default := true;
            }
            else {
              code→setup_defaults;
              code→default_buttons;
              data→refresh := true;
              code→\u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438;
            }
          }
        }
      }
    }
  }
}

action lookup_station() returns label: String, code1: String {
  $label := "";
  $code1 := "";
  $s := "";
  while $s→equals("") do {
    $s := wall→ask_string(code→\_("Введите несколько первых букв названия станции\n"));
  }
  $json := web→download_json("http://tutu.ru/station/suggest.php?name=" ∥ web→url_encode($s));
  if not $json→is_invalid then {
    $labels := collections→create_string_collection;
    $codes := collections→create_string_collection;
    foreach json2 in $json where true do {
      $lab1 := $json2→string("label");
      $strings1 := $json2→string("value")→split("|");
      foreach s2 in $strings1 where true do {
        $codes→add($s2→split("-")→at(0));
        $labels→add($lab1);
      }
    }
    if $labels→count = 1 then {
      $label := $labels→at(0);
      $code1 := $codes→at(0);
    }
    else {
      if $labels→count > 0 then {
        $x := wall→pick_string(code→\_("Найдены следующие станции"), "", $labels);
        if not $x→is_invalid then {
          $label := $labels→at($x);
          $code1 := $codes→at($x);
        }
      }
      else {
        code→\_("Ни одной станции не найдено. Проверьте введенные буквы, или попробуйте добавить еще букв к условию поиска.")→post_to_wall;
      }
    }
  }
  meta private;
}
var morn_name : String {
}
var afternoon_name : String {
}
var afternoon_code : String {
}
var morning_starts : DateTime {
}
var afternoon_starts : DateTime {
}

action setup_defaults() {
  data→padding := "                                                                       ";
  data→morning_starts := time→create(2000, 1, 1, 3, 0, 0);
  data→afternoon_starts := time→create(2000, 1, 1, 12, 0, 0);
  data→proximity := 5000;
  if data→saved_routes→is_invalid then {
    data→saved_routes := collections→create_string_collection;
  }
  if data→timetable_cache→is_invalid then {
    data→timetable_cache := collections→create_string_collection;
  }
  if data→cache_index→is_invalid then {
    data→cache_index := collections→create_string_collection;
    data→cache_index→clear;
  }
  if data→tile_routes→is_invalid then {
    data→tile_routes := ",,," →split(",");
  }
  data→context := collections→create_string_collection;
  data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_1_tile→set_title(code→\_("маршрут 1"));
  data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_1_tile→set_back_title(data→padding ∥ "маршрут 1");
  data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_2_tile→set_title(code→\_("маршрут 2"));
  data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_2_tile→set_back_title(data→padding ∥ "маршрут 2");
  data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_3_tile→set_title(code→\_("маршрут 3"));
  data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_3_tile→set_back_title(data→padding ∥ "маршрут 3");
  data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_4_tile→set_title(code→\_("маршрут 4"));
  data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_4_tile→set_back_title(data→padding ∥ "маршрут 4");
  data→main_tile→set_back_title(data→padding ∥ "маршруты");
  data→main_tile→set_background(colors→accent);
  if data→main_tile→icon→is_invalid then {
    data→main_tile→set_icon(art→icon);
  }
  data→\u0442\u0443\u0434\u0430_\u0438_\u043E\u0431\u0440\u0430\u0442\u043D\u043E_tile→set_title(code→\_("туда и обратно"));
  data→\u0442\u0443\u0434\u0430_\u0438_\u043E\u0431\u0440\u0430\u0442\u043D\u043E_tile→set_back_title(data→padding ∥ "туда и обратно");
  data→tile_to_update := "";
  data→refresh := false;
  data→buttons_shown := false;
  meta private;
}

action calculate_destination() returns source_name: String, source_code: String, dest_name: String, dest_code: String {
  $trip_to := data→afternoon_code;
  $now := time→now;
  $morn := time→create($now→year, $now→month, $now→day, data→morning_starts→hour, data→morning_starts→minute, 0);
  $afternoon := time→create($now→year, $now→month, $now→day, data→afternoon_starts→hour, data→afternoon_starts→minute, 0);
  if($now→greater($morn) and $now→less($afternoon)) or $now→equals($morn) then {
    $trip_to := data→morn_code;
  }
  if $trip_to→equals(data→morn_code) then {
    $source_name := code→shorten_station_name(data→afternoon_name);
    $source_code := data→afternoon_code;
    $dest_name := code→shorten_station_name(data→morn_name);
    $dest_code := data→morn_code;
  }
  else {
    $source_name := code→shorten_station_name(data→morn_name);
    $source_code := data→morn_code;
    $dest_name := code→shorten_station_name(data→afternoon_name);
    $dest_code := data→afternoon_code;
  }
  meta private;
}

action display_timetable(source: String, source_code: String, destination: String, destination_code: String) {
  if code→display_cached_table($source, $source_code, $destination, $destination_code) then {
    wall→set_subtitle(code→\_("Отображается закешированное расписание. Актуальное расписание будет отображено после скачивания."));
  }
  code→download_and_display($source, $source_code, $destination, $destination_code);
  meta private;
}
var links : Sprite_Set {
}
var urls : String_Collection {
}

event tap_sprite_in_links(sprite: Sprite, index_in_set: Number, x: Number, y: Number) {
  web→browse(data→urls→at($index_in_set));
  meta private;
}
var back : Sprite_Set {
}

event tap_sprite_in_back(sprite: Sprite, index_in_set: Number, x: Number, y: Number) {
  code→display_timetable(data→context→at(2), data→context→at(3), data→context→at(0), data→context→at(1));
  meta private;
}

action prepare_route() {
  $source_name, $source_code, $dest_name, $dest_code := code→calculate_destination();
  $on_wall := false;
  $original_dest := $dest_code;
  if data→hint_status > 0 and not data→hint→is_invalid then {
    if code→display_cached_table($source_name, $source_code, $dest_name, $dest_code) then {
      wall→set_subtitle(code→\_("Отображается закешированный маршрут без корректировки с использованием местоположения-подсказки. Корректировка будет произведена после определения местоположения."));
      $on_wall := true;
    }
    $source_name, $source_code, $dest_name, $dest_code := code→adjust_route_as_per_hint($source_name, $source_code, $dest_name, $dest_code);
    if $original_dest→equals($dest_code) then {
      if $on_wall then {
        wall→set_subtitle(code→\_("Отображается закешированное расписание. Актуальное расписание будет отображено после скачивания."));
      }
      code→download_and_display($source_name, $source_code, $dest_name, $dest_code);
    }
    else {
      if code→display_cached_table($source_name, $source_code, $dest_name, $dest_code) then {
        wall→set_subtitle(code→\_("Отображается закешированное расписание. Актуальное расписание будет отображено после скачивания."));
      }
      code→download_and_display($source_name, $source_code, $dest_name, $dest_code);
    }
  }
  else {
    code→display_timetable($source_name, $source_code, $dest_name, $dest_code);
  }
  meta private;
}

action ask_afternoon_station() {
  wall→clear;
  $hint := code→\_("(Вечерняя станция считается пунктом назначения с ") ∥ data→afternoon_starts→hour ∥ code→\_("  часов до ") ∥ data→morning_starts→hour ∥ code→\_(" часов следующего дня)");
  wall→set_subtitle(code→\_("Введите вечернюю станцию назначения") ∥ $hint);
  $label, $code1 := code→lookup_station();
  if not $code1→is_empty and not $label→is_empty then {
    data→afternoon_name := $label;
    data→afternoon_code := $code1→split("-")→at(0);
    (code→\_("Вечерняя станция назначения ") ∥ $label)→post_to_wall;
    if wall→ask_boolean(code→\_("Хотите назначить изображение для этой станции?"), code→\_("Оно будет отображаться на плитке стартового экрана.")) then {
      data→afternoon_pic := code→select_tile_pic(data→\u0442\u0443\u0434\u0430_\u0438_\u043E\u0431\u0440\u0430\u0442\u043D\u043E_tile);
    }
  }
  else {
    wall→prompt(code→\_("Не удалось получить информацию о станции."));
  }
  meta private;
}

action ask_morn_station() {
  wall→clear;
  $hint := code→\_("(Утренняя станция считается пунктом назначения с ") ∥ data→morning_starts→hour ∥ code→\_("  часов до ") ∥ data→afternoon_starts→hour ∥ code→\_(" часов)");
  wall→set_subtitle(code→\_("Введите утреннюю станцию назначения") ∥ $hint);
  $label, $code1 := code→lookup_station();
  if not $code1→is_empty and not $label→is_empty then {
    data→morn_name := $label;
    data→morn_code := $code1→split("-")→at(0);
    (code→\_("Утренняя станция назначения ") ∥ $label)→post_to_wall;
    if wall→ask_boolean(code→\_("Хотите назначить изображение для этой станции?"), code→\_("Оно будет отображаться на плитке стартового экрана.")) then {
      data→morn_pic := code→select_tile_pic(data→\u0442\u0443\u0434\u0430_\u0438_\u043E\u0431\u0440\u0430\u0442\u043D\u043E_tile);
    }
  }
  else {
    wall→prompt(code→\_("Не удалось получить информацию о станции."));
  }
  meta private;
}

action \u0441\u0431\u0440\u043E\u0441_\u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043A() {
  // Сброс настроек
  if wall→ask_boolean(code→\_("Действительно сбросить настройки?"), code→\_("При следующем запуске пункты назначения нужно будет задать заново.")) then {
    data→morn_name := "";
    data→morn_code := "";
    data→afternoon_name := "";
    data→afternoon_code := "";
    data→hint_status := 0;
    data→saved_routes := collections→create_string_collection;
    data→timetable_cache := collections→create_string_collection;
    data→cache_index := collections→create_string_collection;
    data→tile_routes := ",,," →split(",");
    code→\_("Настройки сброшены")→post_to_wall;
    code→reset_tile_(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_1_tile);
    code→reset_tile_(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_2_tile);
    code→reset_tile_(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_3_tile);
    code→reset_tile_(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_4_tile);
    code→reset_tile_(data→\u0442\u0443\u0434\u0430_\u0438_\u043E\u0431\u0440\u0430\u0442\u043D\u043E_tile);
    code→reset_tile_(data→main_tile);
    data→pic_1 := invalid→picture;
    data→pic_2 := invalid→picture;
    data→pic_3 := invalid→picture;
    data→pic_4 := invalid→picture;
    data→morn_pic := invalid→picture;
    data→afternoon_pic := invalid→picture;
    data→start_screen := "";
    //
    while wall→pages→count > 1 do {
      wall→pop_page;
    }
    code→main;
  }
}
var sequence : Number {
}
var hint : Location {
}
var hint_status : Number {
  // 0 - не задан; 1 - утренний; 2 - вечерний
}

action ask_location_hint() {
  $dist := code→\_("примерно в пределах ") ∥ data→proximity / 1000 ∥ code→\_(" км");
  wall→set_subtitle(code→\_("Задайте текущее местоположение в качестве подсказки. При нахождении ") ∥ $dist ∥ code→\_(" от заданного места, будет предлагаться маршрут, НАЧИНАЮЩИЙСЯ со станции назначения соответствующего времени суток, а не заканчивающийся ей как обычно."));
  $options := "" →split("");
  $options→clear;
  $options→add(code→\_("Не сейчас"));
  $options→add(code→\_("Не хочу использовать местоположение"));
  $options→add(code→\_("Утреннее место назначения"));
  $options→add(code→\_("Вечернее место назначения"));
  $selection := wall→pick_string(code→\_("Задание местоположения-подсказки"), code→\_("Охарактеризуйте текущее местоположение."), $options);
  if $selection→is_invalid then {
    $selection := 0;
  }
  $selection := $selection - 1;
  if $selection ≥ 0 then {
    if $selection > 0 then {
      $loc := senses→current_location;
      if $loc→is_invalid then {
        wall→prompt(code→\_("Определение местоположение завершилось неудачно."));
      }
      else {
        data→hint_status := $selection;
        data→hint := $loc;
      }
    }
  }
  if data→hint_status = 0 then {
    code→\_("Местоположение не будет использоваться для корректировки направления маршрута.")→post_to_wall;
  }
  else {
    (code→\_("Задано местоположение-подсказка: ") ∥ data→hint)→post_to_wall;
    if data→hint_status = 1 then {
      code→\_("Эта подсказка находится по близости от утреннего пункта назначения.")→post_to_wall;
    }
    else {
      code→\_("Эта подсказка находится по близости от вечернего пункта назначения.")→post_to_wall;
    }
  }
  meta private;
}

action adjust_route_as_per_hint(souce_name: String, source_code: String, dest_name: String, dest_code: String) returns adj_src_name: String, adj_src_code: String, adj_dest_name: String, adj_dest_code: String {
  $adj_dest_code := $dest_code;
  $here := senses→current_location;
  if $here→is_invalid then {
    wall→prompt(code→\_("Определение местоположение завершилось неудачно."));
    $adj_dest_code := $dest_code;
  }
  else {
    $nearby := data→hint→distance($here) * 1000 ≤ data→proximity;
    if $dest_code→equals(data→morn_code) and data→hint_status = 1 and $nearby then {
      $adj_dest_code := data→afternoon_code;
    }
    if $dest_code→equals(data→afternoon_code) and data→hint_status = 2 and $nearby then {
      $adj_dest_code := data→morn_code;
    }
  }
  if $adj_dest_code→equals($dest_code) then {
    $adj_dest_name := $dest_name;
    $adj_src_code := $source_code;
    $adj_src_name := $souce_name;
  }
  else {
    $adj_dest_name := $souce_name;
    $adj_src_code := $dest_code;
    $adj_src_name := $dest_name;
  }
  meta private;
}
var proximity : Number {
}

action \u043F\u043E\u0434\u0441\u043A\u0430\u0437\u043A\u0430_\u043D\u0430_\u043A\u0430\u0440\u0442\u0435() {
  // Отображение места действия подсказки на карте.
  wall→clear;
  if data→hint_status ≠ 0 and not data→hint→is_invalid then {
    $map := maps→create_map;
    $map→fill_region(code→draw_circle_2(data→hint, data→proximity, 24), colors→accent→make_transparent(.5), colors→transparent, 1);
    $loc := senses→current_location;
    $map→fill_region(code→draw_circle_2($loc, 100, 24), colors→red→make_transparent(.5), colors→transparent, 1);
    $map→set_zoom(code→compute_map_zoom(math→max(2 * data→proximity, $loc→distance(data→hint) * 1000)));
    $hint := social→create_place(code→\_("подсказка"), data→hint);
    $descr := "";
    if data→hint_status = 1 then {
      $descr := code→\_("подсказка установлена по близости от утреннего пункта назначения");
    }
    else {
      $descr := code→\_("подсказка установлена по близости от вечернего пункта назначения");
    }
    $hint→set_category(code→\_("нажмите чтобы изменить"));
    $hint→post_to_wall;
    $descr→post_to_wall;
    $map→add_text($loc, code→\_("вы здесь"), colors→red, colors→foreground);
    $map→post_to_wall;
  }
  else {
    $map1 := maps→create_map;
    $loc1 := senses→current_location;
    $map1→fill_region(code→draw_circle_2($loc1, 100, 24), colors→red→make_transparent(.5), colors→transparent, 1);
    $map1→set_zoom(code→compute_map_zoom(2 * data→proximity));
    $hint1 := social→create_place(code→\_("вы здесь"), $loc1);
    $descr1 := code→\_("подсказка не задана");
    $hint1→set_category(code→\_("нажмите чтобы задать"));
    $hint1→post_to_wall;
    $descr1→post_to_wall;
    $map1→add_text($loc1, code→\_("вы здесь"), colors→red, colors→foreground);
    $map1→post_to_wall;
  }
}
var saved_routes : String_Collection {
}

action \u0432\u0432\u043E\u0434_\u043C\u0430\u0440\u0448\u0440\u0443\u0442\u0430(x1: Number) {
  // Поиск расписания между двумя станциями
  code→setup_defaults;
  code→ask_route_stations;
}

action shorten_station_name(name: String) returns shortened: String {
  $shortened := $name→split("(")→at(0);
  meta private;
}

action render_json(json: Json_Object, source: String, source_code: String, destination: String, destination_code: String) {
  wall→clear;
  $today := time→now;
  $count := 0;
  $now := time→now;
  if $now→hour < data→morning_starts→hour then {
    $now := $now→add_days(1);
  }
  $b := media→create_board(640);
  $w := 80;
  $h := 50;
  $f := 25;
  $y := 25;
  $sputnik := art→sputnik;
  $express := art→express;
  $resched := colors→accent;
  $padding := "                                                                                 ";
  $padding := $padding ∥ $padding ∥ $padding ∥ $padding;
  //
  $same_terminal := true;
  $terminal := invalid→string;
  if $json→count > 0 then {
    $terminal := $json→at(0)→string("terminal");
  }
  else {
    $same_terminal := false;
  }
  foreach json1 in $json where $same_terminal do {
    $same_terminal := $same_terminal and $json1→string("terminal")→equals($terminal);
  }
  $same_origin := true;
  $origin := invalid→string;
  if $json→count > 0 then {
    $origin := $json→at(0)→string("origin");
  }
  else {
    $same_origin := false;
  }
  foreach json2 in $json where $same_origin do {
    $same_origin := $same_origin and $json2→string("origin")→equals($origin);
  }
  if $same_terminal and not $same_origin then {
    code→render_json_flipped($json, $source, $source_code, $destination, $destination_code);
  }
  else {
    $from := $b→create_text($b→width, $h, $f, $source→to_upper_case ∥ $padding);
    $from→set_pos($from→width / 2, $y);
    $from→set_color(colors→subtle);
    $y := $y + $from→height;
    //
    $back := $b→create_text(50, 60, 50, "↺");
    $back→set_pos($w / 3, $y - 5 * $f / 6);
    $back→set_color(colors→accent);
    data→back := $b→create_sprite_set;
    data→back→add($back);
    //
    $to := $b→create_text($b→width, $h, $f, $destination→to_upper_case ∥ $padding);
    $to→set_pos($w + $to→width / 2, $y);
    $to→set_color(colors→subtle);
    $y := $y + $to→height;
    //
    $i := 0;
    $found := false;
    while $i < $json→count and not $found do {
      $@then := $json→at($i)→string("departure")→to_datetime;
      if $@then→hour < data→morning_starts→hour then {
        $@then := $@then→add_days(1);
      }
      $found := $@then→greater_or_equal($now);
      if not $found then {
        $i := $i + 1;
      }
    }
    //
    while $i < $json→count and $count < 10 do {
      $j := $json→at($i);
      $x := 0;
      $c := colors→foreground;
      if $j→string("sputnik")→equals("1") then {
        $c := $sputnik;
      }
      if $j→string("express")→equals("1") then {
        $c := $express;
      }
      if $j→string("rescheduled")→equals("1") then {
        $c := $resched;
      }
      $departure := $b→create_text($w, $h, $f, $j→string("departure") ∥ $padding);
      $departure→set_pos($x + $departure→width / 2, $y);
      $departure→set_color($c);
      $x := $x + $departure→width;
      $arrival := $b→create_text($w, $h, $f, $j→string("arrival") ∥ $padding);
      $arrival→set_pos($x + $arrival→width / 2, $y);
      $arrival→set_color($c);
      $x := $x + $arrival→width;
      $terminal1 := $b→create_text($b→width, $h, $f, $j→string("terminal") ∥ $padding);
      $terminal1→set_pos($x + $terminal1→width / 2, $y);
      $terminal1→set_color($c);
      $x := $x + $terminal1→width;
      $y := $y + $terminal1→height;
      $count := $count + 1;
      $i := $i + 1;
    }
    //
    if $count = 0 then {
      $b→create_text($b→width, $h, $f, code→\_("Вдруг ушли все поезда...")→to_upper_case ∥ $padding)→set_color(colors→accent);
    }
    //
    $y := $y + $h / 2;
    $link := $b→create_text($b→width, 1.75 * $h, $f * .7, code→\_("Полная версия расписания на сайте туту.ру"));
    $link→set_color(colors→accent);
    $link→set_pos($link→width / 2, math→max($y, $b→height - $h));
    data→links := $b→create_sprite_set;
    data→links→add($link);
    data→urls := "" →split("");
    data→urls→clear;
    $tutu := "http://tutu.ru/rasp.php?";
    $tutu := $tutu ∥ "st1=" ∥ web→url_encode($source_code);
    $tutu := $tutu ∥ "&st2=" ∥ web→url_encode($destination_code);
    $today := $today→add_hours( - 3);
    $tutu := $tutu ∥ "&date=" ∥ $today→day ∥ "." ∥ $today→month ∥ "." ∥ $today→year;
    data→urls→add($tutu);
    //
    $b→post_to_wall;
  }
  //

  meta private;
}

action update_tile(json: Json_Object, source: String, destination: String, tile: Tile, source_code: String, destination_code: String) {
  $today := time→now;
  $count := 0;
  $@table := "" →split("");
  $@table→clear;
  $now := time→now;
  if $now→hour < data→morning_starts→hour then {
    $now := $now→add_days(1);
  }
  //
  $i := 0;
  $found := false;
  while $i < $json→count and not $found do {
    $@then := $json→at($i)→string("departure")→to_datetime;
    if $@then→hour < data→morning_starts→hour then {
      $@then := $@then→add_days(1);
    }
    $found := $@then→greater_or_equal($now);
    if not $found then {
      $i := $i + 1;
    }
  }
  //
  while $i < $json→count and $count < 10 do {
    $j := $json→at($i);
    $suffix := "";
    if $j→string("sputnik")→equals("1") then {
      $suffix := "★";
    }
    if $j→string("express")→equals("1") then {
      $suffix := "★";
    }
    if $@table→count < 4 then {
      $@table→add($j→string("departure") ∥ $suffix);
    }
    $count := $count + 1;
    $i := $i + 1;
  }
  //
  if not $tile→is_invalid then {
    $c := code→tile_color($tile);
    $tile→set_background($c);
    $pic := media→create_picture($tile→width, $tile→height);
    $assigned_pic := code→pic_for_tile($tile→back_title, $destination_code);
    $tile→set_content("");
    if not $assigned_pic→is_invalid then {
      $pic := media→create_picture($tile→width, $tile→height);
      $pic→blend($assigned_pic, - ($assigned_pic→width - $pic→width) / 2, - ($assigned_pic→height - $pic→height) / 2, 0, 1);
      $strings := $destination→trim(" \t")→split(" ");
      $y := 2;
      foreach s1 in $strings where true do {
        $pic→draw_text(5, $y, $s1, 30, 0, colors→foreground);
        $y := $y + 33;
      }
      $tile→set_icon($pic);
    }
    else {
      if $source→is_empty or $destination→is_empty then {
        $tile→clear_back_icon;
        $tile→clear_icon;
      }
      else {
        $strings1 := ($source→trim(" \t"))→split(" ");
        $s := $strings1→at($strings1→count - 1) ∥ " ·";
        $strings1→remove_at($strings1→count - 1);
        $strings1→add($s);
        $strings1→add_many($destination→trim(" \t")→split(" "));
        $y2 := 2;
        foreach s3 in $strings1 where true do {
          $pic→draw_text(0, $y2, $s3, 30, 0, colors→foreground);
          $y2 := $y2 + 33;
        }
        $tile→set_icon($pic);
      }
    }
    $pic := media→create_picture(150, 160);
    $y1 := 2;
    foreach s2 in $@table where true do {
      $pic→draw_text(0, $y1, $s2, 30, 0, colors→foreground);
      $y1 := $y1 + 33;
    }
    $tile→set_back_icon($pic);
    ... ;
    // Copy to chosen main tile
    code→copy_tile(code→get_chosen_tile);
  }
  meta private;
}

action reset_tile_(tile: Tile) {
  if not $tile→is_invalid then {
    $c := code→tile_color($tile);
    $tile→set_background($c);
    $tile→set_content("");
    $tile→clear_back_icon;
    $tile→clear_icon;
    $tile→set_icon(art→icon);
    code→clear_tile_pic($tile→title, invalid→string);
    ... ;
    // Copy to chosen main tile
    code→copy_tile(code→get_chosen_tile);
  }
  meta private;
}
var timetable_cache : String_Collection {
}

action look_in_cache(source: String, destination: String, kind: String) returns json: String {
  $json := "";
  $key := $source ∥ "<->" ∥ $destination;
  if data→cache_index→contains($key) then {
    $idx := data→cache_index→index_of($key, 0);
    if $kind→equals("table") then {
      $json := data→timetable_cache→at($idx);
    }
    if $kind→equals("route") then {
      $json := data→saved_routes→at($idx);
    }
  }
  meta private;
}

action save_in_cache(source: String, destination: String, json: String, kind: String) {
  $key := $source ∥ "<->" ∥ $destination;
  if not data→cache_index→contains($key) then {
    data→cache_index→add($key);
    data→timetable_cache→add("");
    data→saved_routes→add("");
  }
  if data→cache_index→contains($key) then {
    $idx := data→cache_index→index_of($key, 0);
    if $kind→equals("table") then {
      data→timetable_cache→set_at($idx, $json);
    }
    if $kind→equals("route") then {
      data→saved_routes→set_at($idx, $json);
    }
  }
  meta private;
}
var cache_index : String_Collection {
}

action delete_from_cache(source: String, destination: String) {
  $key := $source ∥ "<->" ∥ $destination;
  if data→cache_index→contains($key) then {
    $idx := data→cache_index→index_of($key, 0);
    data→timetable_cache→set_at($idx, "");
    data→saved_routes→set_at($idx, "");
  }
  code→remove_route_tile($source, $destination);
  meta private;
}
var context : String_Collection {
}

action update_context(s1: String, s2: String, s3: String, s4: String) {
  data→context→clear;
  data→context→add($s1);
  data→context→add($s2);
  data→context→add($s3);
  data→context→add($s4);
  meta private;
}

action load_saved_routes() returns routes: String_Collection {
  $routes := "" →split("");
  $routes→clear;
  for 0 ≤ i < data→cache_index→count do {
    if $routes→count < 40 then {
      $s := data→saved_routes→at($i);
      if not $s→equals("") then {
        $routes→add_many(data→cache_index→at($i)→split("<->"));
        $routes→add_many($s→split("<->"));
      }
    }
  }
  meta private;
}
var route_controls : Sprite_Set {
}

action render_saved_routes(routes: String_Collection) {
  wall→clear;
  wall→set_subtitle(code→\_("перечеркните маршрут чтобы удалить"));
  $i := 0;
  $b := media→create_board(640);
  $w := 80;
  $h := 56;
  $f := 28;
  $y := $f / 2;
  $padding := "                                                                                 ";
  $padding := $padding ∥ $padding ∥ $padding ∥ $padding;
  data→route_controls := $b→create_sprite_set;
  data→small_tile_controls := $b→create_sprite_set;
  //
  while $i < $routes→count and $i < 32 do {
    $source_name := $routes→at($i + 2);
    $destination_name := $routes→at($i + 3);
    $source_code := $routes→at($i);
    $destination_code := $routes→at($i + 1);
    $i := $i + 4;
    $sprite1 := $b→create_text($b→width, $f, $f, $source_name ∥ $padding);
    $sprite1→set_pos($w + $b→width / 2, $y);
    data→route_controls→add($sprite1);
    //
    $small_tile := $b→create_rectangle($w * .75, $w * .75);
    $small_tile→set_pos($w / 2, $y + $h / 2 - $f / 3);
    $tile_label := code→tile_number($source_code, $destination_code)→to_string;
    $tile_color := code→tile_color_by_route($source_code, $destination_code);
    if $tile_color→is_invalid then {
      $tile_label := "?";
      $tile_color := colors→chrome;
    }
    $small_tile→set_color($tile_color);
    data→small_tile_controls→add($small_tile);
    $sprite := $b→create_text(10, $f, $f, $tile_label);
    $sprite→set_pos($small_tile→x - $small_tile→width / 4, $small_tile→y - $small_tile→height / 4);
    data→small_tile_controls→add($sprite);
    //
    $sprite1 := $b→create_text($b→width, $f, $f, " ↪ " ∥ $destination_name ∥ $padding);
    $sprite1→set_pos($w + $b→width / 2, $y + $h / 2);
    data→route_controls→add($sprite1);
    $y := $y + $h + 12;
  }
  //
  if $i = 0 then {
    $b→create_text($b→width, $h, $f, code→\_("Сохраненных маршрутов нет.")→to_upper_case ∥ $padding)→set_color(colors→accent);
  }
  //
  data→new_route_control := $b→create_sprite_set;
  $button := $b→create_rectangle($b→width * 0.5, $f * 1.75);
  $button→set_pos($b→width / 2, $b→height - $button→height);
  data→new_route_control→add($button);
  $sprite2 := $b→create_rectangle($button→width - 6, $button→height - 6);
  $sprite2→set_pos($button→x, $button→y);
  $sprite2→set_color(colors→background);
  data→new_route_control→add($sprite2);
  $sprite2 := $b→create_text($button→width, $button→height, $f, code→\_("ввод маршрута"));
  $sprite2→set_pos($button→x, $button→y);
  data→new_route_control→add($sprite2);
  //
  $b→post_to_wall;
  meta private;
}

event tap_sprite_in_route_controls(sprite: Sprite, index_in_set: Number, x: Number, y: Number) {
  $routes := code→load_saved_routes();
  $i := 4 * math→floor($index_in_set / 2);
  $source_name := code→shorten_station_name($routes→at($i + 2));
  $destination_name := code→shorten_station_name($routes→at($i + 3));
  $source_code := $routes→at($i);
  $destination_code := $routes→at($i + 1);
  if data→tile_to_update→is_empty then {
    $tile := code→find_route_tile($source_code, $destination_code);
    if not $tile→is_invalid then {
      data→tile_to_update := $tile→back_title→trim_start(" \t");
    }
    else {
      data→tile_to_update := "маршруты";
    }
  }
  wall→push_new_page;
  code→display_timetable($source_name, $source_code, $destination_name, $destination_code);
  meta private;
}
var new_route_control : Sprite_Set {
}

event tap_sprite_in_new_route_control(sprite: Sprite, index_in_set: Number, x: Number, y: Number) {
  wall→push_new_page;
  code→ask_route_stations;
  meta private;
}

action \u043C\u0430\u0440\u0448\u0440\u0443\u0442\u044B() {
  // Выбор одного из 8 введенных ранее маршрутов
  code→setup_defaults;
  code→default_buttons;
  code→render_saved_routes(code→load_saved_routes);
}

action \u0442\u0443\u0434\u0430_\u0438_\u043E\u0431\u0440\u0430\u0442\u043D\u043E() {
  // Поиск расписания между утренней и вечерней станциями
  //
  // С 3 до полудня выводятся прямые маршруты, а с 12 до 3 утра - обратные. На экране расписания нажмите на пиктограмму указателя, чтобы посмотреть расписание в обратном направлении.
  //
  code→setup_defaults;
  code→there_and_back;
}

event swipe_sprite_in_route_controls(sprite: Sprite, index_in_set: Number, x: Number, y: Number, delta_x: Number, delta_y: Number) {
  $routes := code→load_saved_routes();
  $i := 4 * math→floor($index_in_set / 2);
  $source_name := $routes→at($i + 2);
  $destination_name := $routes→at($i + 3);
  $source_code := $routes→at($i);
  $destination_code := $routes→at($i + 1);
  if wall→ask_boolean(code→\_("Удалить маршрут из списка?"), $source_name ∥ " · " ∥ $destination_name) then {
    code→delete_from_cache($source_code, $destination_code);
  }
  code→render_saved_routes(code→load_saved_routes);
  meta private;
}
var morn_code : String {
}

action display_n\u002Dth_route(i: Number) {
  code→default_buttons;
  data→tile_to_update := "маршрут " ∥ $i + 1;
  $route := code→find_route_by_tile($i);
  if $route→count > 0 then {
    $source_name := code→shorten_station_name($route→at(2));
    $destination_name := code→shorten_station_name($route→at(3));
    $source_code := $route→at(0);
    $destination_code := $route→at(1);
    code→display_timetable($source_name, $source_code, $destination_name, $destination_code);
  }
  else {
    code→render_saved_routes(code→load_saved_routes);
  }
  meta private;
}

action \u043C\u0430\u0440\u0448\u0440\u0443\u0442_1() {
  // Прикрепите на стартовый экран как live tile
  code→setup_defaults;
  code→display_n\u002Dth_route(0);
}

action \u043C\u0430\u0440\u0448\u0440\u0443\u0442_2() {
  // Прикрепите на стартовый экран как live tile
  code→setup_defaults;
  code→display_n\u002Dth_route(1);
}

action \u043C\u0430\u0440\u0448\u0440\u0443\u0442_3() {
  // Прикрепите на стартовый экран как live tile
  code→setup_defaults;
  code→display_n\u002Dth_route(2);
}

action \u043C\u0430\u0440\u0448\u0440\u0443\u0442_4() {
  // Прикрепите на стартовый экран как live tile
  code→setup_defaults;
  code→display_n\u002Dth_route(3);
}
var tile_to_update : String {
}
var tile_routes : String_Collection {
}

action tile_color(tile: Tile) returns color: Color {
  $color := colors→accent;
  meta private;
}

action select_tile() {
  wall→clear;
  $b := media→create_board(640);
  data→tile_controls := $b→create_sprite_set;
  $tile := $b→create_rectangle(170, 170);
  $tile→set_color(colors→accent);
  $tile→set_pos($tile→width / 2 + 5, $tile→height / 2 + 5);
  data→tile_controls→add($tile);
  $label := $b→create_text($tile→width, 20, 20, code→\_("маршрут 1"));
  $label→set_x($tile→x - 25);
  $label→set_y($tile→y + $tile→height / 2 - 30);
  data→tile_controls→add($label);
  $label := $b→create_text(10, 10, 60, "1");
  $label→set_x($tile→x - $tile→width / 2 + 10);
  $label→set_y($tile→y - $tile→height / 2 + 10);
  data→tile_controls→add($label);
  //
  $tile := $b→create_rectangle(170, 170);
  $tile→set_color(colors→accent);
  $tile→set_pos(3 * $tile→width / 2 + 20, $tile→height / 2 + 5);
  data→tile_controls→add($tile);
  $label := $b→create_text($tile→width, 20, 20, code→\_("маршрут 2"));
  $label→set_x($tile→x - 25);
  $label→set_y($tile→y + $tile→height / 2 - 30);
  data→tile_controls→add($label);
  $label := $b→create_text(10, 10, 60, "2");
  $label→set_x($tile→x - $tile→width / 2 + 10);
  $label→set_y($tile→y - $tile→height / 2 + 10);
  data→tile_controls→add($label);
  //
  $tile := $b→create_rectangle(170, 170);
  $tile→set_color(colors→accent);
  $tile→set_pos($tile→width / 2 + 5, 3 * $tile→height / 2 + 20);
  data→tile_controls→add($tile);
  $label := $b→create_text($tile→width, 20, 20, code→\_("маршрут 3"));
  $label→set_x($tile→x - 25);
  $label→set_y($tile→y + $tile→height / 2 - 30);
  data→tile_controls→add($label);
  $label := $b→create_text(10, 10, 60, "3");
  $label→set_x($tile→x - $tile→width / 2 + 10);
  $label→set_y($tile→y - $tile→height / 2 + 10);
  data→tile_controls→add($label);
  //
  $tile := $b→create_rectangle(170, 170);
  $tile→set_color(colors→accent);
  $tile→set_pos(3 * $tile→width / 2 + 20, 3 * $tile→height / 2 + 20);
  data→tile_controls→add($tile);
  $label := $b→create_text($tile→width, 20, 20, code→\_("маршрут 4"));
  $label→set_x($tile→x - 25);
  $label→set_y($tile→y + $tile→height / 2 - 30);
  data→tile_controls→add($label);
  $label := $b→create_text(10, 10, 60, "4");
  $label→set_x($tile→x - $tile→width / 2 + 10);
  $label→set_y($tile→y - $tile→height / 2 + 10);
  data→tile_controls→add($label);
  $b→post_to_wall;
  meta private;
}
var tile_controls : Sprite_Set {
}

event tap_sprite_in_tile_controls(sprite: Sprite, index_in_set: Number, x: Number, y: Number) {
  $i := math→floor($index_in_set / 3);
  $old_route := code→find_route_by_tile($i);
  $create := true;
  if $old_route→count > 0 then {
    if not $old_route→at(0)→equals(data→context→at(1)) and not $old_route→at(1)→equals(data→context→at(3)) then {
      if wall→ask_boolean(code→\_("Заменить ранее прикрепленный маршрут? "), $old_route→at(2) ∥ " · " ∥ $old_route→at(3)) then {
        code→remove_route_tile($old_route→at(0), $old_route→at(1));
      }
      else {
        $create := false;
        code→select_tile;
      }
    }
    else {
      code→remove_route_tile($old_route→at(0), $old_route→at(1));
    }
  }
  if $create then {
    data→refresh := true;
    code→set_tile_route($i, data→context→at(1), data→context→at(3));
    $tile1 := code→find_route_tile(data→context→at(1), data→context→at(3));
    if not $tile1→is_invalid then {
      data→tile_to_update := $tile1→back_title→trim_start(" \t");
      if wall→ask_boolean(code→\_("Хотите назначить изображение для этой станции?"), code→\_("Оно будет отображаться на плитке стартового экрана.")) then {
        code→set_tile_pic($tile1→back_title, code→select_tile_pic($tile1));
      }
      if wall→ask_boolean(code→\_("Открывать маршрут с плитки стартового экрана?"), "") then {
        data→start_screen := code→\_("маршрут " ∥ ($i + 1));
      }
    }
    code→display_timetable(data→context→at(0), data→context→at(1), data→context→at(2), data→context→at(3));
  }
  meta private;
}

action tile_by_index(index: Number) returns tile: Tile {
  $tile := invalid→tile;
  if $index = 0 then {
    $tile := data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_1_tile;
  }
  else {
    if $index = 1 then {
      $tile := data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_2_tile;
    }
    else {
      if $index = 2 then {
        $tile := data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_3_tile;
      }
      else {
        if $index = 3 then {
          $tile := data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_4_tile;
        }
      }
    }
  }
  meta private;
}

action find_route_tile(source: String, destination: String) returns tile: Tile {
  $tile := invalid→tile;
  $key := $source ∥ "<->" ∥ $destination;
  if data→tile_routes→contains($key) then {
    $tile := code→tile_by_index(data→tile_routes→index_of($key, 0));
  }
  meta private;
}

action remove_route_tile(source: String, destination: String) {
  $key := $source ∥ "<->" ∥ $destination;
  if data→tile_routes→contains($key) then {
    code→reset_tile_(code→tile_by_index(data→tile_routes→index_of($key, 0)));
    data→tile_routes→set_at(data→tile_routes→index_of($key, 0), "");
  }
  meta private;
}

action set_tile_route(index: Number, source: String, destination: String) {
  code→reset_tile_(code→tile_by_index($index));
  code→remove_route_tile($source, $destination);
  data→tile_routes→set_at($index, $source ∥ "<->" ∥ $destination);
  meta private;
}

action find_route_by_tile(index: Number) returns route: String_Collection {
  $route := "" →split("");
  $route→clear;
  $key := data→tile_routes→at($index);
  if not $key→equals("") then {
    $route→add_many($key→split("<->"));
    $route→add_many(code→look_in_cache($route→at(0), $route→at(1), "route")→split("<->"));
  }
  meta private;
}
var small_tile_controls : Sprite_Set {
}

event tap_sprite_in_small_tile_controls(sprite: Sprite, index_in_set: Number, x: Number, y: Number) {
  wall→push_new_page;
  $routes := code→load_saved_routes();
  $i := 4 * math→floor($index_in_set / 2);
  $source_name := code→shorten_station_name($routes→at($i + 2));
  $destination_name := code→shorten_station_name($routes→at($i + 3));
  $source_code := $routes→at($i);
  $destination_code := $routes→at($i + 1);
  code→update_context($source_name, $source_code, $destination_name, $destination_code);
  code→select_tile;
  meta private;
}

action tile_number(source: String, destination: String) returns number: Number {
  $number := 0;
  $key := $source ∥ "<->" ∥ $destination;
  if data→tile_routes→contains($key) then {
    $number := data→tile_routes→index_of($key, 0) + 1;
  }
  meta private;
}

action tile_by_id(id: String) returns tile: Tile {
  $tile := invalid→tile;
  if data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_1_tile→back_title→trim_start(" \t")→equals($id) then {
    $tile := data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_1_tile;
  }
  if data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_2_tile→back_title→trim_start(" \t")→equals($id) then {
    $tile := data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_2_tile;
  }
  if data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_3_tile→back_title→trim_start(" \t")→equals($id) then {
    $tile := data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_3_tile;
  }
  if data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_4_tile→back_title→trim_start(" \t")→equals($id) then {
    $tile := data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_4_tile;
  }
  if data→\u0442\u0443\u0434\u0430_\u0438_\u043E\u0431\u0440\u0430\u0442\u043D\u043E_tile→back_title→trim_start(" \t")→equals($id) then {
    $tile := data→\u0442\u0443\u0434\u0430_\u0438_\u043E\u0431\u0440\u0430\u0442\u043D\u043E_tile;
  }
  if data→main_tile→back_title→trim_start(" \t")→equals($id) then {
    $tile := data→main_tile;
  }
  meta private;
}

action tile_color_by_route(source: String, destination: String) returns color: Color {
  $color := invalid→color;
  if not code→find_route_tile($source, $destination)→is_invalid then {
    $color := colors→accent;
  }
  meta private;
}
var sputnik : Color {
  is\_resource = true;
  url = "#ff3dba3d";
}
var express : Color {
  is\_resource = true;
  url = "#ff3d92ba";
}

action render_json_flipped(json: Json_Object, source: String, source_code: String, destination: String, destination_code: String) {
  wall→clear;
  $today := time→now;
  $count := 0;
  $now := time→now;
  if $now→hour < data→morning_starts→hour then {
    $now := $now→add_days(1);
  }
  $b := media→create_board(640);
  $w := 80;
  $h := 50;
  $f := 25;
  $y := 25;
  $sputnik := art→sputnik;
  $express := art→express;
  $resched := colors→accent;
  $padding := "                                                                                 ";
  $padding := $padding ∥ $padding ∥ $padding ∥ $padding;
  //
  $pad := "";
  for 0 ≤ i < 48 - 2 * $destination→count do {
    $pad := $pad ∥ " ";
  }
  $to := $b→create_text($b→width - $w, $h, $f, $pad ∥ $destination→to_upper_case);
  $to→set_pos($w + $to→width / 2, $y);
  $to→set_color(colors→subtle);
  $y := $y + $to→height;
  //
  $pad := "";
  for 0 ≤ i2 < 38 - 2 * $source→count do {
    $pad := $pad ∥ " ";
  }
  $from := $b→create_text($b→width, $h, $f, $pad ∥ $source→to_upper_case);
  $from→set_pos($from→width / 2, $y);
  $from→set_color(colors→subtle);
  //
  $back := $b→create_text(50, 60, 50, "↻");
  $back→set_pos($b→width - $w / 3 * 2, $y - 5 * $f / 6);
  $back→set_color(colors→accent);
  data→back := $b→create_sprite_set;
  data→back→add($back);
  $y := $y + $from→height;
  //
  $i1 := 0;
  $found := false;
  while $i1 < $json→count and not $found do {
    $@then := $json→at($i1)→string("departure")→to_datetime;
    if $@then→hour < data→morning_starts→hour then {
      $@then := $@then→add_days(1);
    }
    $found := $@then→greater_or_equal($now);
    if not $found then {
      $i1 := $i1 + 1;
    }
  }
  //
  while $i1 < $json→count and $count < 10 do {
    $j := $json→at($i1);
    $x := 0;
    $c := colors→foreground;
    if $j→string("sputnik")→equals("1") then {
      $c := $sputnik;
    }
    if $j→string("express")→equals("1") then {
      $c := $express;
    }
    if $j→string("rescheduled")→equals("1") then {
      $c := $resched;
    }
    $origin := $b→create_text($b→width - 2 * $w, $h, $f, $j→string("origin") ∥ $padding);
    $origin→set_pos($x + $origin→width / 2, $y);
    $origin→set_color($c);
    $x := $x + $origin→width;
    $departure := $b→create_text($w, $h, $f, $j→string("departure") ∥ $padding);
    $departure→set_pos($x + $departure→width / 2, $y);
    $departure→set_color($c);
    $x := $x + $departure→width;
    $arrival := $b→create_text($w, $h, $f, $j→string("arrival") ∥ $padding);
    $arrival→set_pos($x + $arrival→width / 2, $y);
    $arrival→set_color($c);
    $x := $x + $arrival→width;
    $y := $y + $origin→height;
    $count := $count + 1;
    $i1 := $i1 + 1;
  }
  //
  if $count = 0 then {
    $b→create_text($b→width, $h, $f, code→\_("Вдруг ушли все поезда...")→to_upper_case ∥ $padding)→set_color(colors→accent);
  }
  //
  $y := $y + $h / 2;
  $link := $b→create_text($b→width, 1.75 * $h, $f * .7, code→\_("Полная версия расписания на сайте туту.ру"));
  $link→set_color(colors→accent);
  $link→set_pos($link→width / 2, math→max($y, $b→height - $h));
  data→links := $b→create_sprite_set;
  data→links→add($link);
  data→urls := "" →split("");
  data→urls→clear;
  $tutu := "http://tutu.ru/rasp.php?";
  $tutu := $tutu ∥ "st1=" ∥ web→url_encode($source_code);
  $tutu := $tutu ∥ "&st2=" ∥ web→url_encode($destination_code);
  $today := $today→add_hours( - 3);
  $tutu := $tutu ∥ "&date=" ∥ $today→day ∥ "." ∥ $today→month ∥ "." ∥ $today→year;
  data→urls→add($tutu);
  //
  $b→post_to_wall;
  //

  meta private;
}

action display_cached_table(source: String, source_code: String, destination: String, destination_code: String) returns done: Boolean {
  $done := false;
  code→update_context($source, $source_code, $destination, $destination_code);
  $cached := web→json(code→look_in_cache($source_code, $destination_code, "table"));
  if not $cached→is_invalid and $cached→keys→count > 0 then {
    code→render_json($cached→field("value")→field("items"), $source, $source_code, $destination, $destination_code);
    $done := true;
  }
  meta private;
}

action download_and_display(source: String, source_code: String, destination: String, destination_code: String) {
  code→update_context($source, $source_code, $destination, $destination_code);
  $today := time→now;
  $url := "http://pipes.yahoo.com/pipes/pipe.run?_id=0f68e83b16f26ba95d6172b55c1042a9&_render=json";
  $url := $url ∥ "&source=" ∥ web→url_encode($source_code);
  $url := $url ∥ "&destination=" ∥ web→url_encode($destination_code);
  data→sequence := data→sequence + 1;
  $url := $url ∥ "&sequence=" ∥ web→url_encode(data→sequence ∥ "");
  $raw := web→download($url);
  if $raw→is_invalid then {
    wall→prompt(code→\_("Не удалось скачать расписание."));
  }
  else {
    $json := web→json($raw);
    if not $json→is_invalid and not $json→field("value")→is_invalid and not $json→field("value")→field("items")→is_invalid then {
      wall→set_subtitle("");
      $json := $json→field("value")→field("items");
      code→render_json($json, $source, $source_code, $destination, $destination_code);
      $tile := code→tile_by_id(data→tile_to_update);
      if not $tile→is_invalid then {
        code→update_tile($json, $source, $destination, $tile, $source_code, $destination_code);
        data→tile_to_update := "";
      }
      code→save_in_cache($source_code, $destination_code, $raw, "table");
    }
    else {
      wall→prompt(code→\_("Не удалось скачать расписание."));
    }
  }
  meta private;
}

action pic_for_tile(tile: String, destination: String) returns pic: Picture {
  $pic := invalid→picture;
  if $tile→equals(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_1_tile→back_title) then {
    $pic := data→pic_1;
  }
  else {
    if $tile→equals(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_2_tile→back_title) then {
      $pic := data→pic_2;
    }
    else {
      if $tile→equals(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_3_tile→back_title) then {
        $pic := data→pic_3;
      }
      else {
        if $tile→equals(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_4_tile→back_title) then {
          $pic := data→pic_4;
        }
        else {
          if $tile→equals(data→\u0442\u0443\u0434\u0430_\u0438_\u043E\u0431\u0440\u0430\u0442\u043D\u043E_tile→back_title) then {
            if $destination→equals(data→morn_code) then {
              $pic := data→morn_pic;
            }
            else {
              if $destination→equals(data→afternoon_code) then {
                $pic := data→afternoon_pic;
              }
            }
          }
        }
      }
    }
  }
  meta private;
}

action clear_tile_pic(tile: String, destination: String) {
  if $tile→equals(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_1_tile→title) then {
    data→pic_1 := invalid→picture;
  }
  else {
    if $tile→equals(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_2_tile→title) then {
      data→pic_2 := invalid→picture;
    }
    else {
      if $tile→equals(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_3_tile→title) then {
        data→pic_3 := invalid→picture;
      }
      else {
        if $tile→equals(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_4_tile→title) then {
          data→pic_4 := invalid→picture;
        }
        else {
          if $tile→equals(data→\u0442\u0443\u0434\u0430_\u0438_\u043E\u0431\u0440\u0430\u0442\u043D\u043E_tile→title) then {
            if $destination→is_invalid then {
              data→morn_pic := invalid→picture;
              data→afternoon_pic := invalid→picture;
            }
            else {
              if $destination→equals(data→morn_code) then {
                data→morn_pic := invalid→picture;
              }
              else {
                if $destination→equals(data→afternoon_code) then {
                  data→afternoon_pic := invalid→picture;
                }
              }
            }
          }
        }
      }
    }
  }
  meta private;
}
var pic_1 : Picture {
}
var pic_2 : Picture {
}
var pic_4 : Picture {
}
var morn_pic : Picture {
}
var afternoon_pic : Picture {
}

action select_tile_pic(tile: Tile) returns pic: Picture {
  $pic := media→choose_picture;
  if not $pic→is_invalid then {
    if $pic→is_panorama then {
      $pic→resize( - 1, $tile→height);
    }
    else {
      if not $pic→is_panorama then {
        $pic→resize($tile→width, - 1);
      }
    }
  }
  meta private;
}

action set_tile_pic(tile: String, pic: Picture) {
  if $tile→equals(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_1_tile→back_title) then {
    data→pic_1 := $pic;
  }
  else {
    if $tile→equals(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_2_tile→back_title) then {
      data→pic_2 := $pic;
    }
    else {
      if $tile→equals(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_3_tile→back_title) then {
        data→pic_3 := $pic;
      }
      else {
        if $tile→equals(data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_4_tile→back_title) then {
          data→pic_4 := $pic;
        }
      }
    }
  }
  meta private;
}

action \u043E\u0447\u0438\u0441\u0442\u043A\u0430_\u043A\u0435\u0448\u0430() {
  // Очищает закещированные расписания. Полезно, если в кеш попали некорректные данные.
  if wall→ask_boolean(code→\_("Очистить кеш?"), "") then {
    $count := data→timetable_cache→count;
    $strings := collections→create_string_collection;
    for 0 ≤ i < $count do {
      $strings→add("");
    }
    data→timetable_cache := $strings;
    code→\_("Кеш очищен.")→post_to_wall;
  }
}
var start_screen : String {
}

action \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438() {
  $page := wall→push_new_page;
  wall→set_subtitle(code→\_("Плитка стартового экрана открывает"));
  $strut := media→create_picture(1, 48);
  $tb := wall→create_text_box(code→\_("маршрут 4"), 28);
  $tb→set_icon($strut);
  if $tb→text→equals(data→start_screen) then {
    $tb→set_foreground(colors→accent);
  }
  $tb→post_to_wall;
  $tb := wall→create_text_box(code→\_("маршрут 3"), 28);
  $tb→set_icon($strut);
  if $tb→text→equals(data→start_screen) then {
    $tb→set_foreground(colors→accent);
  }
  $tb→post_to_wall;
  $tb := wall→create_text_box(code→\_("маршрут 2"), 28);
  $tb→set_icon($strut);
  if $tb→text→equals(data→start_screen) then {
    $tb→set_foreground(colors→accent);
  }
  $tb→post_to_wall;
  $tb := wall→create_text_box(code→\_("маршрут 1"), 28);
  $tb→set_icon($strut);
  if $tb→text→equals(data→start_screen) then {
    $tb→set_foreground(colors→accent);
  }
  $tb→post_to_wall;
  $tb := wall→create_text_box(code→\_("туда и обратно"), 28);
  $tb→set_icon($strut);
  if $tb→text→equals(data→start_screen) then {
    $tb→set_foreground(colors→accent);
  }
  $tb→post_to_wall;
  $tb := wall→create_text_box(code→\_("маршруты"), 28);
  $tb→set_icon($strut);
  if $tb→text→equals(data→start_screen) then {
    $tb→set_foreground(colors→accent);
  }
  $tb→post_to_wall;
  wall→add_button("edit", code→\_("станции"));
  wall→add_button("delete", code→\_("сброс"));
  wall→add_button("share", code→\_("кеш"));
  //

}

event tap_wall_TextBox(item: TextBox) {
  data→start_screen := $item→text;
  if data→start_screen→equals(code→\_("маршруты")) then {
    data→main_tile→set_title("Туда и обратно");
  }
  code→copy_tile(code→get_chosen_tile);
  wall→pop_page;
  meta private;
}

action draw_circle_2(loc: Location, radius: Number, arcs: Number) returns ls: Location_Collection {
  // Produces a set of points, that when connected on a map will look like a circle. loc is the center and radius is in meters. The circle will be comprised of the given number of arcs.
  code→setup_geo;
  $ls := locations→create_location_list;
  $x := 0;
  for 0 ≤ i < $arcs do {
    $x := $x + math→\u03C0 * math→\u03C0 / $arcs * math→sin($i * math→\u03C0 / $arcs);
    $loc1 := code→compute_coords_2($loc, $x, $radius);
    $ls→add($loc1);
  }
  $ls→add($ls→at(0));
  meta private;
}

action compute_map_zoom(distance: Number) returns zoom: Number {
  // Selects Bing maps zoom level most appropriate for displaying two objects at given distance on meters.
  code→setup_geo;
  $zoom := 21 - 19 * math→log($distance / 2, data→maximum) + math→cos(math→\u03C0 * $distance / 2 / data→maximum / 2);
  meta private;
}

action location_at_distance(origin: Location, bearing_deg: Number, distance: Number) returns destination: Location {
  // Computes coordinates of a point located at given distance in meters from origin. Bearing is in degrees.
  code→setup_geo;
  $destination := code→compute_coords_2($origin, math→deg_to_rad($bearing_deg), $distance);
  meta private;
}

action setup_geo() {
  data→R := 6371000;
  if data→maximum = 0 then {
    data→maximum := 3500000;
  }
  meta private;
}
var maximum : Number {
}
var R : Number {
}

action compute_coords_2(loc: Location, bearing: Number, distance: Number) returns result: Location {
  $x := $distance / data→R;
  $lat := math→sin(math→deg_to_rad($loc→latitude)) * math→cos($x);
  $lat := $lat + math→cos(math→deg_to_rad($loc→latitude)) * math→sin($x) * math→cos($bearing);
  $lat := math→asin($lat);
  $lon := math→sin($bearing) * math→sin($x) * math→cos(math→deg_to_rad($loc→latitude));
  $lon := math→atan2($lon, math→cos($x) - math→sin(math→deg_to_rad($loc→latitude)) * math→sin($lat));
  $lon := math→deg_to_rad($loc→longitude) + $lon;
  $lat := math→rad_to_deg($lat);
  $lon := math→rad_to_deg($lon);
  ... ;
  if math→abs($lat) > 90 then {
    $lat := - math→sign($lat) * 90 + math→mod($lat, 90);
    $lon := - math→sign($lon) * 180 + math→mod($lon, 180);
  }
  else {
    if math→abs($lon) > 180 then {
      $lon := - math→sign($lon) * 180 + math→mod($lon, 180);
    }
  }
  $result := locations→create_location($lat, $lon);
  meta private;
}

event tap_wall_Page_Button(item: Page_Button) {
  data→launch_default := false;
  //
  if $item→text→equals(code→\_("гео")) then {
    wall→push_new_page;
    code→\u043F\u043E\u0434\u0441\u043A\u0430\u0437\u043A\u0430_\u043D\u0430_\u043A\u0430\u0440\u0442\u0435;
  }
  else {
    if $item→text→equals(code→\_("свойства")) then {
      code→\u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438;
    }
    else {
      if $item→text→equals(code→\_("маршруты")) then {
        code→render_saved_routes(code→load_saved_routes);
      }
      else {
        if $item→text→starts_with(code→\_("туда-")) then {
          code→there_and_back;
        }
        else {
          if $item→text→equals(code→\_("сброс")) then {
            code→\u0441\u0431\u0440\u043E\u0441_\u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043A;
          }
          else {
            if $item→text→equals(code→\_("кеш")) then {
              code→\u043E\u0447\u0438\u0441\u0442\u043A\u0430_\u043A\u0435\u0448\u0430;
            }
            else {
              if $item→text→equals(code→\_("станции")) then {
                data→morn_name := "";
                data→morn_code := "";
                data→afternoon_name := "";
                data→afternoon_code := "";
                wall→pop_page;
                wall→clear_buttons;
                data→buttons_shown := false;
                wall→clear;
                code→there_and_back;
              }
            }
          }
        }
      }
    }
  }
  meta private;
}
var map : Map {
}

action copy_tile(source: Tile) {
  $destination := data→main_tile;
  if $source→back_icon→is_invalid then {
    $destination→clear_back_icon;
  }
  else {
    $destination→set_back_icon($source→back_icon);
  }
  $destination→set_background($source→background);
  if $source→content→is_invalid then {
    $destination→set_content("");
  }
  else {
    $destination→set_content($source→content);
  }
  $destination→set_counter($source→counter);
  $destination→set_title($source→title);
  if $source→icon→is_invalid then {
    $destination→clear_icon;
  }
  else {
    $destination→set_icon($source→icon);
  }
  meta private;
}

action get_chosen_tile() returns tile: Tile {
  $tile := data→main_tile;
  if data→start_screen→equals(code→\_("туда и обратно")) then {
    $tile := data→\u0442\u0443\u0434\u0430_\u0438_\u043E\u0431\u0440\u0430\u0442\u043D\u043E_tile;
  }
  else {
    if data→start_screen→equals(code→\_("маршрут 1")) then {
      $tile := data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_1_tile;
    }
    else {
      if data→start_screen→equals(code→\_("маршрут 2")) then {
        $tile := data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_2_tile;
      }
      else {
        if data→start_screen→equals(code→\_("маршрут 3")) then {
          $tile := data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_3_tile;
        }
        else {
          if data→start_screen→equals(code→\_("маршрут 4")) then {
            $tile := data→\u043C\u0430\u0440\u0448\u0440\u0443\u0442_4_tile;
          }
        }
      }
    }
  }
  meta private;
}

action default_buttons() {
  if not data→buttons_shown then {
    data→buttons_shown := true;
    wall→add_button("favs", code→\_("маршруты"));
    wall→add_button("refresh", code→\_("туда-обратно"));
    wall→add_button("basecircle", code→\_("гео"));
    wall→add_button("feature.settings", code→\_("свойства"));
  }
  meta private;
}
var pic_3 : Picture {
}
var refresh : Boolean {
}

event page_navigated_from() {
  if wall→pages→count = 1 and data→refresh then {
    data→refresh := false;
    code→render_saved_routes(code→load_saved_routes);
  }
  meta private;
}

event tap_wall_Place(item: Place) {
  wall→push_new_page;
  code→ask_location_hint;
  wall→pop_page;
  code→\u043F\u043E\u0434\u0441\u043A\u0430\u0437\u043A\u0430_\u043D\u0430_\u043A\u0430\u0440\u0442\u0435;
  meta private;
}

action \_(@in: String) returns out: String {
  $out := invalid→string;
  if languages→current_language→equals("ru") then {
    $out := $@in;
  }
  else {
    if $@in→equals("Открывать маршрут с плитки стартового экрана?") then {
      $out := "Open this route from start tile?";
    }
    if $@in→equals("Заменить ранее прикрепленный маршрут? ") then {
      $out := "Replace previously pinned route?";
    }
    if $@in→equals("Удалить маршрут из списка?") then {
      $out := "Remove route from the list?";
    }
    if $@in→equals("ввод маршрута") then {
      $out := "add route";
    }
    if $@in→equals("Сохраненных маршрутов нет.") then {
      $out := "No saved routes";
    }
    if $@in→equals("перечеркните маршрут чтобы удалить") then {
      $out := "swipe the route to remove it";
    }
    if $@in→equals("Полная версия расписания на сайте туту.ру") then {
      $out := "Full version of the timetable at tutu.ru";
    }
    if $@in→equals("Вдруг ушли все поезда...") then {
      $out := "Nobody Here But Us Chickens";
    }
    if $@in→equals("Ни одной станции не найдено. Проверьте введенные буквы, или попробуйте добавить еще букв к условию поиска.") then {
      $out := "No stations found. Check the entered letters or try to add more letters to the search input.";
    }
    if $@in→equals("Найдены следующие станции") then {
      $out := "Found the following stations";
    }
    if $@in→equals("Введите несколько первых букв названия станции\n") then {
      $out := "Enter first several letters of the station name\n";
    }
    if $@in→equals("Не удалось скачать расписание.") then {
      $out := "Failed to retrieve the timetable.";
    }
    if $@in→equals("Отображается закешированный маршрут без корректировки с использованием местоположения-подсказки. Корректировка будет произведена после определения местоположения.") then {
      $out := "Cached timetable for route is displayed without correction based on the location hint. Correction will be performed after current location is determined.";
    }
    if $@in→equals("Отображается закешированное расписание. Актуальное расписание будет отображено после скачивания.") then {
      $out := "Cached timetable is displayed. Up to date timetable will be displayed once download completes.";
    }
    if $@in→equals("свойства") then {
      $out := "settings";
    }
    if $@in→equals("гео") then {
      $out := "location";
    }
    if $@in→equals("туда-") then {
      $out := "there&";
    }
    if $@in→equals("туда-обратно") then {
      $out := "there&back";
    }
    if $@in→equals("Эта подсказка находится по близости от вечернего пункта назначения.") then {
      $out := "This hint is located in the vicinity of the afternoon destination.";
    }
    if $@in→equals("Эта подсказка находится по близости от утреннего пункта назначения.") then {
      $out := "This hint is located in the vicinity of the morning destination.";
    }
    if $@in→equals("Задано местоположение-подсказка: ") then {
      $out := "Location hint set to:";
    }
    if $@in→equals("Местоположение не будет использоваться для корректировки направления маршрута.") then {
      $out := "Location information will not be used to correct suggested route direction.";
    }
    if $@in→equals("Охарактеризуйте текущее местоположение.") then {
      $out := "Describe your vicinity.";
    }
    if $@in→equals("Задание местоположения-подсказки") then {
      $out := "Location hint set up";
    }
    if $@in→equals("Вечернее место назначения") then {
      $out := "The afternoon destination";
    }
    if $@in→equals("Утреннее место назначения") then {
      $out := "The morning destination";
    }
    if $@in→equals("Не хочу использовать местоположение") then {
      $out := "I don\'t want to use location information";
    }
    if $@in→equals("Не сейчас") then {
      $out := "Not now";
    }
    if $@in→equals(" от заданного места, будет предлагаться маршрут, НАЧИНАЮЩИЙСЯ со станции назначения соответствующего времени суток, а не заканчивающийся ей как обычно.") then {
      $out := " from the place set as the hint, suggested route will START from the destination of the corresponding time of day, not end with it as usual.";
    }
    if $@in→equals("Задайте текущее местоположение в качестве подсказки. При нахождении ") then {
      $out := "Set current location as the hint. When ";
    }
    if $@in→equals(" км") then {
      $out := " km";
    }
    if $@in→equals("примерно в пределах ") then {
      $out := "nearer than approximately ";
    }
    if $@in→equals("Не удалось получить информацию о станции.") then {
      $out := "Failed to retrieve station data.";
    }
    if $@in→equals("маршруты") then {
      $out := "routes";
    }
    if $@in→equals("туда и обратно") then {
      $out := "there and back";
    }
    if $@in→equals("маршрут 4") then {
      $out := "route 4";
    }
    if $@in→equals("маршрут 3") then {
      $out := "route 3";
    }
    if $@in→equals("маршрут 2") then {
      $out := "route 2";
    }
    if $@in→equals("маршрут 1") then {
      $out := "route 1";
    }
    if $@in→equals("Введите станцию отправления") then {
      $out := "Enter boarding station";
    }
    if $@in→equals("Введите станцию назначения") then {
      $out := "Enter destination station";
    }
    if $@in→equals("Плитка стартового экрана открывает") then {
      $out := "Start tile opens";
    }
    if $@in→equals("станции") then {
      $out := "stations";
    }
    if $@in→equals("сброс") then {
      $out := "reset";
    }
    if $@in→equals("кеш") then {
      $out := "cache";
    }
    if $@in→equals("Очистить кеш?") then {
      $out := "Clear the cache?";
    }
    if $@in→equals("Кеш очищен.") then {
      $out := "Cache cleared.";
    }
    if $@in→equals("подсказка") then {
      $out := "hint";
    }
    if $@in→equals("подсказка установлена по близости от утреннего пункта назначения") then {
      $out := "hint set in vicinity of the morning destination";
    }
    if $@in→equals("подсказка установлена по близости от вечернего пункта назначения") then {
      $out := "hint set in vicinity of the afternoon destination";
    }
    if $@in→equals("нажмите чтобы изменить") then {
      $out := "tap to change";
    }
    if $@in→equals("вы здесь") then {
      $out := "you are here";
    }
    if $@in→equals("подсказка не задана") then {
      $out := "hint is not set";
    }
    if $@in→equals("нажмите чтобы задать") then {
      $out := "tap to set";
    }
    if $@in→equals("Действительно сбросить настройки?") then {
      $out := "Reset all settings?";
    }
    if $@in→equals("При следующем запуске пункты назначения нужно будет задать заново.") then {
      $out := "All routes and destinations will be gone next time app runs.";
    }
    if $@in→equals("Настройки сброшены") then {
      $out := "Settings reset";
    }
    if $@in→equals("Определение местоположение завершилось неудачно.") then {
      $out := "Failed to determine current location.";
    }
    if $@in→equals("(Утренняя станция считается пунктом назначения с ") then {
      $out := "(The morning destination will be selected from ";
    }
    if $@in→equals("(Вечерняя станция считается пунктом назначения с ") then {
      $out := "(The afternoon destination will be selected from ";
    }
    if $@in→equals("  часов до ") then {
      $out := "  hours till ";
    }
    if $@in→equals(" часов)") then {
      $out := " hours)";
    }
    if $@in→equals(" часов следующего дня)") then {
      $out := " hours next day early morning)";
    }
    if $@in→equals("Введите утреннюю станцию назначения") then {
      $out := "Enter the morning destination station";
    }
    if $@in→equals("Введите вечернюю станцию назначения") then {
      $out := "Enter the afternoon destination station";
    }
    if $@in→equals("Утренняя станция назначения ") then {
      $out := "The morning destination is ";
    }
    if $@in→equals("Вечерняя станция назначения ") then {
      $out := "The afternoon destination is ";
    }
    if $@in→equals("Хотите назначить изображение для этой станции?") then {
      $out := "Would you like to assign a picture for this destination?";
    }
    if $@in→equals("Оно будет отображаться на плитке стартового экрана.") then {
      $out := "It will be displayed on the start tile.";
    }
    if $@in→is_empty then {
      $out := $@in;
    }
  }
  ... ;
  meta private;
}
var buttons_shown : Boolean {
}
var main_tile : Tile {
  readonly = true;
}
var \u043C\u0430\u0440\u0448\u0440\u0443\u0442_1_tile : Tile {
  readonly = true;
}
var \u043C\u0430\u0440\u0448\u0440\u0443\u0442_2_tile : Tile {
  readonly = true;
}
var \u043C\u0430\u0440\u0448\u0440\u0443\u0442_3_tile : Tile {
  readonly = true;
}
var \u043C\u0430\u0440\u0448\u0440\u0443\u0442_4_tile : Tile {
  readonly = true;
}
var \u0442\u0443\u0434\u0430_\u0438_\u043E\u0431\u0440\u0430\u0442\u043D\u043E_tile : Tile {
  readonly = true;
}

action there_and_back() {
  code→default_buttons;
  data→tile_to_update := "туда и обратно";
  $ask_location := false;
  if data→morn_code→is_empty then {
    code→ask_morn_station;
    $ask_location := not data→morn_code→is_empty;
  }
  if data→afternoon_code→is_empty then {
    code→ask_afternoon_station;
    $ask_location := $ask_location or not data→morn_code→is_empty;
  }
  if $ask_location then {
    wall→clear;
    code→ask_location_hint;
  }
  if not data→morn_code→is_empty and not data→afternoon_code→is_empty then {
    code→prepare_route;
  }
  meta private;
}

action ask_route_stations() {
  wall→clear;
  wall→set_subtitle(code→\_("Введите станцию отправления"));
  $slab, $scode := code→lookup_station();
  while $scode→is_empty do {
    $slab, $scode := code→lookup_station();
  }
  wall→clear;
  wall→set_subtitle(code→\_("Введите станцию назначения"));
  $dlab, $dcode := code→lookup_station();
  while $dcode→is_empty do {
    $dlab, $dcode := code→lookup_station();
  }
  code→save_in_cache($scode, $dcode, $slab ∥ "<->" ∥ $dlab, "route");
  $short_dlab := code→shorten_station_name($dlab);
  $short_slab := code→shorten_station_name($slab);
  if data→tile_to_update→is_empty then {
    $tile := code→find_route_tile($scode, $dcode);
    if not $tile→is_invalid then {
      data→tile_to_update := $tile→back_title→trim_start(" \t");
    }
    else {
      data→tile_to_update := "маршруты";
    }
  }
  data→refresh := true;
  code→display_timetable($short_slab, $scode, $short_dlab, $dcode);
  meta private;
}

action default_action() {
  if data→start_screen→is_empty then {
    data→start_screen := code→\_("маршруты");
  }
  if data→start_screen→equals(code→\_("маршруты")) then {
    code→render_saved_routes(code→load_saved_routes);
  }
  else {
    if data→start_screen→equals(code→\_("туда и обратно")) then {
      code→there_and_back;
    }
    else {
      if data→start_screen→equals(code→\_("маршрут 1")) then {
        code→display_n\u002Dth_route(0);
      }
      else {
        if data→start_screen→equals(code→\_("маршрут 2")) then {
          code→display_n\u002Dth_route(1);
        }
        else {
          if data→start_screen→equals(code→\_("маршрут 3")) then {
            code→display_n\u002Dth_route(2);
          }
          else {
            if data→start_screen→equals(code→\_("маршрут 4")) then {
              code→display_n\u002Dth_route(3);
            }
            else {
              data→refresh := true;
              code→\u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438;
            }
          }
        }
      }
    }
  }
  meta private;
}
var app_start : DateTime {
}
var launch_default : Boolean {
}

event gameloop() {
  if data→launch_default then {
    if time→now→subtract(data→app_start) ≥ 2 then {
      data→launch_default := false;
      code→default_action;
    }
  }
  meta private;
}
var padding : String {
}
var icon : Picture {
  is\_resource = true;
  url = "https://dl.dropbox.com/s/bwvcttvoj82l8ri/tile.png";
}

