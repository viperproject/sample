action main() {
  // The board holds sprites and a physics engine. Stored in data so that it can be accessed in the game loop event.
  dataâ†’board := mediaâ†’create_full_board;
  // Keep the sprites from leaving the screen.
  dataâ†’boardâ†’create_boundary(0);
  // A circle sprite of 50 pixels diameter
  skip;
  skip;
  skip;
  dataâ†’sprite := dataâ†’boardâ†’create_text(100, 100, 150, "ðŸ’—");
  // You can change the sprite color, size, shape...
  dataâ†’spriteâ†’set_color(colorsâ†’red);
  // Increase friction to slow the sprite
  skip;
  // Decrease elasticity to reduce bounces
  dataâ†’spriteâ†’set_elasticity(1.0);
  // Display the board and start the game loop
  dataâ†’boardâ†’post_to_wall;
}

//:: ExpectedOutput(backward.counterexample.found)
event gameloop() {
  $acc := sensesâ†’acceleration_quick;
  //:: ExpectedOutput(assert.failed)
  $a := $accâ†’scale(200);
  dataâ†’boardâ†’set_gravity($aâ†’x, $aâ†’y);
  dataâ†’boardâ†’evolve;
  dataâ†’boardâ†’update_on_wall;
  // Add game logic here
  // Get the acceleration and rescale to pixels.
  $accp := sensesâ†’acceleration_quick;
  //:: ExpectedOutput(assert.failed)
  $p := $accpâ†’scale(800);
  // Assign acceleration as board gravity.
  dataâ†’boardâ†’set_gravity($pâ†’x, $pâ†’y);
  // Apply physics
  dataâ†’boardâ†’evolve;
  // Redraw board on wall
  dataâ†’boardâ†’update_on_wall;
  meta private;
}

var board : Board {
  transient = true;
}

var sprite : Sprite {
  transient = true;
}

event tap_sprite\u003a_sprite(sprite: Sprite, x: Number, y: Number) {
  // Vibrate when the sprite is touched...
  phoneâ†’vibrate(0.1);
  $spriteâ†’set_text("ðŸ’”");
  phoneâ†’vibrate(0.1);
  skip;
  skip;
  meta private;
}

action physics() {
  $a := sensesâ†’acceleration_quickâ†’scale(200);
  dataâ†’boardâ†’set_gravity($aâ†’x, $aâ†’y);
  dataâ†’boardâ†’evolve;
  dataâ†’boardâ†’update_on_wall;
  meta private;
}
