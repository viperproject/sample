import ch.ethz.inf.pm.td.webapi.URLFetcher._
import java.io.{File, PrintWriter}
import net.liftweb.json._
import net.liftweb.json.JsonAST.{JArray, JField, JObject}

/**
 * Parses the new JSON based API description an generates type information
 */

val url = "https://www.touchdevelop.com/api/language/apis"
val json = parse(fetchFile(url))

val p = new PrintWriter(new File("TouchDevelopPreprocessing/gen/TypeList.scala"))

try {

  p.println(
    """package ch.ethz.inf.pm.td.compiler
      |
      |import ch.ethz.inf.pm.td.semantics._
      |
      |/**
      | *
      | * AUTOGENERATED BY generate_type_list.scala
      | *
      | * Lucas Brutschy
      | *
      | */
      |
      |object TypeList  {
      |
      |  var types : Map[String, AAny] = Map(
      |    SData.typName -> new SData(),
      |    SCode.typName -> new SCode(),
      |    SArt.typName -> new SArt(),
      |    SRecords.typName -> new SRecords(),
      |    SLibs.typName -> new SLibs(),
      |    SHelpers.typName -> new SHelpers(),
      |""".stripMargin)

  val lines = for (
    JObject(root) <- json;
    JField("types", JArray(types)) <- root;
    typ <- types
  ) yield {
    val JString(name) = typ \ "name"
    val JString(help) = typ \ "help"
    val isData = (typ \ "isData") match { case JBool(x) => x ; case _ => false }

    val className =
      if (isData) "T" + name.replace(" ","_")
      else "S" + name.replace(" ","_")

    "    "+className+".typName -> new "+className+"()"
  }

  p.println(lines.mkString(",\n"))
  p.println(
    """
      |  )
      |
      |}
    """.stripMargin)


} finally {
  p.close()
}
