import ch.ethz.inf.pm.td.webapi.URLFetcher._
import java.io.{File, PrintWriter}
import net.liftweb.json._
import net.liftweb.json.JsonAST.{JArray, JField, JObject}

/**
 * Parses the new JSON based API description an generates type information
 */

object GenerateTypeList {

  def main(args: Array[String]) {
    val url = "https://www.touchdevelop.com/api/language/apis"
    val json = parse(fetchFile(url))

    val p = new PrintWriter(new File("TouchDevelopPreprocessing/gen/TypeList.scala"))

    try {

      p.println(
        """package ch.ethz.inf.pm.td.compiler
          |
          |import ch.ethz.inf.pm.td.analysis.ApiField
          |import ch.ethz.inf.pm.td.parser.{Parameter, TypeName}
          |import ch.ethz.inf.pm.td.semantics._
          |
          |import scala.None
          |
          |/**
          | *
          | * Partly generated by GenerateTypeList
          | *
          | * Lucas Brutschy
          | *
          | */
          |object TypeList  {
          |
          |
          |  def reset() {
          |    userTypes = Map.empty
          |    records = Set.empty
          |  }
          |
          |  var userTypes: Map[TypeName, AAny] = Map.empty
          |  var records: Set[ApiField] = Set.empty
          |
          |
          |  def toTouchType(typeName: TypeName): AAny = {
          |    TypeList.getTypeOrFail(typeName)
          |  }
          |
          |  def toTouchTypes(names: List[TypeName]): List[AAny] = {
          |    for (typeName <- names) yield {
          |      TypeList.getTypeOrFail(typeName)
          |    }
          |  }
          |
          |  def toTouchField(field: Parameter): ApiField = {
          |    ApiField(field.ident, TypeList.getTypeOrFail(field.typeName))
          |  }
          |
          |  def toTouchFields(fields: List[Parameter]): List[ApiField] = {
          |    for (field <- fields) yield {
          |      ApiField(field.ident, TypeList.getTypeOrFail(field.typeName))
          |    }
          |  }
          |
          |  def addTouchType(semantics: AAny) {
          |    TypeList.userTypes += semantics.typeName -> semantics
          |  }
          |
          |  def addRecord(name:String, typ:AAny) {
          |    TypeList.records += ApiField(name,typ)
          |  }
          |
          |  def getSingletons = List(SBazaar,SBox,SCloud_Data,SCloud_Storage,
          |    SColors,SHome,SLanguages,SLocations,SMedia,SPlayer,SRadio,SRecords,SSenses,SSocial,STime,SWall,SWeb)
          |
          |  def getTypeOrFail(typ:TypeName):AAny = getType(typ) match {
          |    case Some(x) => x
          |    case None => throw TouchException("TypeList: Non-existing type detected: "+typ)
          |  }
          |
          |  def getType(typ:TypeName):Option[AAny] = typ match {
          |
          |    case SData.typeName => Some(SData)
          |    case SCode.typeName => Some(SCode)
          |    case SArt.typeName => Some(SArt)
          |    case SRecords.typeName => Some(SRecords)
          |    case SLibs.typeName => Some(SLibs)
          |    case SHelpers.typeName => Some(SHelpers)
          |
          | """.stripMargin)

      val lines = for (
        JObject(root) <- json;
        JField
          ("types", JArray(types)) <- root;
        typ <- types
      ) yield {
          val JString(name) = typ \ "name"
          val isData = typ \ "isData" match {
            case JBool(x) => x
            case _ => false
          }

          val className = if (isData) "T" + name.replace(" ", "_") else "S" + name.replace(" ", "_")

          "    case "+ className + ".typeName => Some(" + className + ")"
        }

      p.println(lines.mkString("\n"))

      p.println( """
                   |    case _ =>
                   |      if (!CFGGenerator.isLibraryIdent(typ.ident)) {
                   |        userTypes.get(typ)
                   |      } else Some(new ASingleton {
                   |        override def typeName: TypeName = typ
                   |      })
                   |  }
                   |
                   |}
                 """.stripMargin)


    } finally {
      p.close()
    }
  }
}
